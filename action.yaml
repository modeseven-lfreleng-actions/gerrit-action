---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# gerrit-server-action
name: "‚öôÔ∏è Gerrit Server Container"
description: |
  Starts Gerrit server(s) with pull-replication plugin for
  mirroring production Gerrit instances

inputs:
  # Mandatory
  gerrit_setup:
    description: |
      JSON array defining Gerrit instances to start.
      Format: [{"slug": "onap", "gerrit": "gerrit.onap.org", "project": "", "api_path": "/r"}]

      Fields:
        - slug (required): Short identifier for the instance
        - gerrit (required): Gerrit server hostname
        - project (optional): Project filter for replication
            - Empty string or omitted: Replicate ALL projects from server
            - Literal name: "releng/lftools" - single project
            - Comma-separated: "releng/lftools,ci-management" - multiple projects
            - Regex pattern: "regex:releng/.*" or "regex:^infra/.*" - pattern matching
        - api_path (optional): API path prefix (e.g., "/infra", "/r", "/gerrit")

      Can be overridden by repository variable GERRIT_SETUP
    required: true

  # Authentication (one method required)
  ssh_private_key:
    description: "SSH private key for Gerrit sync authentication"
    required: false
  ssh_known_hosts:
    description: |
      SSH known_hosts entries for Gerrit servers
      (auto-generated if not provided)
    required: false
  http_username:
    description: |
      HTTP basic auth username
      (required if auth_type=http_basic)
    required: false
  http_password:
    description: |
      HTTP basic auth password
      (required if auth_type=http_basic)
    required: false
  bearer_token:
    description: |
      Bearer token for HTTP authentication
      (required if auth_type=bearer_token)
    required: false

  # Optional - Gerrit Configuration
  gerrit_version:
    description: "Gerrit Docker image version tag"
    required: false
    default: '3.13.1-ubuntu24'
  plugin_version:
    description: "Pull-replication plugin version/branch"
    required: false
    default: 'stable-3.13'
  base_http_port:
    description: "Starting HTTP port (increments for multi-instance)"
    required: false
    default: '8080'
  base_ssh_port:
    description: "Starting SSH port (increments for multi-instance)"
    required: false
    default: '29418'
  auth_type:
    description: "Authentication method: ssh, http_basic, or bearer_token"
    required: false
    default: 'ssh'
  remote_ssh_user:
    description: |
      SSH username for authenticating to remote Gerrit servers.
      This is the account on the REMOTE Gerrit server that has the
      ssh_private_key's corresponding public key registered.
      Can be overridden per-instance in gerrit_setup with 'ssh_user'.
    required: false
    default: 'gerrit'
  remote_ssh_port:
    description: |
      SSH port for remote Gerrit servers (typically 29418).
      Can be overridden per-instance in gerrit_setup with 'ssh_port'.
    required: false
    default: '29418'

  # Optional - Replication Settings
  sync_on_startup:
    description: "Trigger replication after startup"
    required: false
    default: 'true'
  fetch_every:
    description: |
      Interval for pull-replication polling (e.g., '60s', '5m').
      The pull-replication plugin will poll the source Gerrit at this
      interval to fetch any new or changed refs. This enables automatic
      replication while keeping the web UI fully functional.
      Set to '0s' to disable automatic polling.
    required: false
    default: '60s'
  replication_timeout:
    description: "Timeout for initial replication sync (in seconds)"
    required: false
    default: '600'
  sync_refs:
    description: "Refs to synchronize (default: all branches, tags, changes)"
    required: false
    default: '+refs/heads/*:refs/heads/*,+refs/tags/*:refs/tags/*,+refs/changes/*:refs/changes/*'
  replication_threads:
    description: "Number of replication threads per instance"
    required: false
    default: '4'
  max_projects:
    description: |
      Maximum number of projects to fetch from remote Gerrit when no
      project filter is specified. Limits API queries for large instances.
      Set to a higher value if you need to replicate more projects.
    required: false
    default: '800'
  require_replication_success:
    description: |
      If true and sync_on_startup is true, the workflow will fail
      if replication verification fails. Set to false to allow
      the workflow to succeed even if replication issues are detected.
    required: false
    default: 'true'
  replication_wait_timeout:
    description: |
      Maximum time (in seconds) to wait for replication to complete.
      Replication is considered complete when the repository count
      matches the expected count from the remote Gerrit server.
      Increase this value for large Gerrit instances.
      Only used when sync_on_startup is true.
    required: false
    default: '600'

  # Optional - Container Management
  exit:
    description: "Stop containers when the job completes"
    required: false
    default: 'true'
  check_service:
    description: "Verify service availability after startup"
    required: false
    default: 'true'
  enable_cache:
    description: "Enable Docker layer and dependency caching"
    required: false
    default: 'true'
  cache_key_suffix:
    description: "Extra suffix for cache keys"
    required: false
    default: ''

  # Optional - Advanced
  debug:
    description: "Enables debugging output"
    required: false
    default: 'false'
  use_api_path:
    description: |
      When true, the local Gerrit container will use the same URL context
      path as the source/origin server (e.g., /r, /infra). This ensures
      that clone URLs and static content paths match the production server.
      When false, the container serves at root (/).
    required: false
    default: 'false'
  additional_plugins:
    description: "Comma-separated list of extra plugin URLs to install"
    required: false
  gerrit_init_args:
    description: "Extra arguments for gerrit.war init"
    required: false
  skip_plugin_install:
    description: "Skip pull-replication plugin installation (testing)"
    required: false
    default: 'false'
  ssh_auth_keys:
    description: |
      SSH public keys to add for accessing the Gerrit container.
      One key per line, in standard authorized_keys format.

      When ssh_auth_username is also provided, a new Gerrit user
      account will be created with that username and these keys.
      Otherwise, keys are added to the default admin account.

      Example:
        ssh_auth_keys: |
          ssh-ed25519 AAAAC3... user@example.com
          ecdsa-sha2-nistp256 AAAAE2... another@example.com
    required: false
    default: ''
  ssh_auth_username:
    description: |
      Gerrit username to create for SSH access.
      When provided along with ssh_auth_keys, a new Gerrit user
      account will be created with this username and the provided
      SSH public keys.

      If not provided, ssh_auth_keys will be added to the default
      admin account (ID 1000000).

      Example:
        ssh_auth_username: 'myusername'
    required: false
    default: ''
  tunnel_host:
    description: |
      External tunnel hostname for public access.
      Examples: 'bore.pub', Tailscale IP (e.g., '100.x.y.z').

      When set along with tunnel_ports, Gerrit will be configured with
      external URLs for canonicalWebUrl and sshd.advertisedAddress.

      The tunnel should be started before invoking this action, pointing
      to the local ports (base_http_port, base_ssh_port).
    required: false
    default: ''
  tunnel_ports:
    description: |
      JSON object mapping instance slugs to their tunnel port assignments.
      Required when tunnel_host is set. Format:
        {"slug": {"http": 12345, "ssh": 54321}, ...}

      For single-instance setups, use the slug from gerrit_setup.
      The ports are the remote/public ports assigned by the tunnel service.

      Example:
        tunnel_ports: '{"lf-gerrit": {"http": 45678, "ssh": 45679}}'
    required: false
    default: ''

outputs:
  container_ids:
    description: "JSON array of running container IDs"
    value: ${{ steps.collect-outputs.outputs.container_ids }}
  container_ips:
    description: "JSON array of container IP addresses"
    value: ${{ steps.collect-outputs.outputs.container_ips }}
  instances:
    description: |
      JSON object mapping slug to instance details
      {cid, ip, http_port, ssh_port, url, api_path, api_url}
    value: ${{ steps.collect-outputs.outputs.instances }}
  gerrit_urls:
    description: "Comma-separated list of Gerrit HTTP URLs"
    value: ${{ steps.collect-outputs.outputs.gerrit_urls }}
  api_paths:
    description: |
      JSON object mapping slug to API path details
      {gerrit_host, api_path, api_url} for each instance.
      The api_path is the URL prefix (e.g., /r, /infra, /gerrit)
      detected or provided for each Gerrit server.
    value: ${{ steps.collect-outputs.outputs.api_paths }}
  ssh_host_keys:
    description: |
      JSON object mapping slug to SSH host public keys.
      Contains the auto-generated SSH host keys for each Gerrit instance,
      which can be used by downstream steps for automation tasks.
      Format: {slug: {ssh_host_rsa_key: "...", ssh_host_ed25519_key: "...", ...}}
    value: ${{ steps.collect-outputs.outputs.ssh_host_keys }}

runs:
  using: "composite"
  steps:
    - name: 'Setup action/environment'
      id: setup
      shell: bash
      run: |
        # Setup Gerrit server action environment and validate configuration
        set -euo pipefail

        echo "# Gerrit Server Action ‚öôÔ∏è" >> "$GITHUB_STEP_SUMMARY"
        echo "" >> "$GITHUB_STEP_SUMMARY"

        # Validate required inputs
        if [ -z "${{ inputs.gerrit_setup }}" ]; then
          echo "::error::gerrit_setup is a mandatory input ‚ùå"
          exit 1
        fi

        # Validate JSON format
        if ! echo '${{ inputs.gerrit_setup }}' | jq empty 2>/dev/null; then
          echo "::error::gerrit_setup is not valid JSON ‚ùå"
          exit 1
        fi

        # Validate authentication
        AUTH_TYPE="${{ inputs.auth_type }}"
        case "$AUTH_TYPE" in
          ssh)
            if [ -z "${{ inputs.ssh_private_key }}" ]; then
              echo "::error::ssh_private_key required when auth_type=ssh ‚ùå"
              exit 1
            fi
            ;;
          http_basic)
            if [ -z "${{ inputs.http_username }}" ] || \
               [ -z "${{ inputs.http_password }}" ]; then
              echo "::error::http_username and http_password required when auth_type=http_basic ‚ùå"
              exit 1
            fi
            ;;
          bearer_token)
            if [ -z "${{ inputs.bearer_token }}" ]; then
              echo "::error::bearer_token required when auth_type=bearer_token ‚ùå"
              exit 1
            fi
            ;;
          *)
            echo "::error::Invalid auth_type: $AUTH_TYPE ‚ùå"
            exit 1
            ;;
        esac

        # Validate port numbers
        if ! [[ "${{ inputs.base_http_port }}" =~ ^[0-9]+$ ]]; then
          echo "::error::base_http_port must be a valid number ‚ùå"
          exit 1
        fi
        if ! [[ "${{ inputs.base_ssh_port }}" =~ ^[0-9]+$ ]]; then
          echo "::error::base_ssh_port must be a valid number ‚ùå"
          exit 1
        fi

        # Validate fetch_every format
        FETCH_EVERY="${{ inputs.fetch_every }}"
        if ! [[ "$FETCH_EVERY" =~ ^[0-9]+[smhSMH]?$ ]]; then
          echo "::error::fetch_every must be a valid interval (e.g., '60s', '5m', '1h', or '0' to disable) ‚ùå"
          exit 1
        fi

        # Create working directory
        WORK_DIR="/tmp/gerrit-action-$$"
        mkdir -p "$WORK_DIR"
        echo "WORK_DIR=$WORK_DIR" >> "$GITHUB_ENV"
        echo "Working directory: $WORK_DIR" >> "$GITHUB_STEP_SUMMARY"

        # Display configuration
        echo "**Configuration** ‚öôÔ∏è" >> "$GITHUB_STEP_SUMMARY"
        echo "- Gerrit version: \`${{ inputs.gerrit_version }}\`" \
          >> "$GITHUB_STEP_SUMMARY"
        echo "- Plugin version: \`${{ inputs.plugin_version }}\`" \
          >> "$GITHUB_STEP_SUMMARY"
        echo "- Auth type: \`${{ inputs.auth_type }}\`" \
          >> "$GITHUB_STEP_SUMMARY"
        echo "- Sync on startup: \`${{ inputs.sync_on_startup }}\`" \
          >> "$GITHUB_STEP_SUMMARY"
        echo "- Fetch interval: \`${{ inputs.fetch_every }}\`" \
          >> "$GITHUB_STEP_SUMMARY"
        echo "- Caching enabled: \`${{ inputs.enable_cache }}\`" \
          >> "$GITHUB_STEP_SUMMARY"
        echo "" >> "$GITHUB_STEP_SUMMARY"

        # Parse instance count
        INSTANCE_COUNT=$(echo '${{ inputs.gerrit_setup }}' | jq '. | length')
        echo "INSTANCE_COUNT=$INSTANCE_COUNT" >> "$GITHUB_ENV"
        echo "**Instances to start:** $INSTANCE_COUNT" >> "$GITHUB_STEP_SUMMARY"
        echo "" >> "$GITHUB_STEP_SUMMARY"

    # Docker Buildx with caching support
    - name: 'Docker Buildx'
      uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      with:
        version: latest
        driver-opts: |
          image=moby/buildkit:latest
          network=host

    # Cache Docker layers for faster builds
    - name: 'Cache Docker layers'
      if: inputs.enable_cache == 'true'
      uses: actions/cache@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
      with:
        path: /tmp/.buildx-cache
        key: gerrit-docker-${{ runner.os }}-${{ inputs.gerrit_version }}${{ inputs.cache_key_suffix }}
        restore-keys: |
          gerrit-docker-${{ runner.os }}-${{ inputs.gerrit_version }}
          gerrit-docker-${{ runner.os }}-
          gerrit-docker-

    # Cache plugin downloads
    - name: 'Cache plugin downloads'
      if: inputs.enable_cache == 'true' && inputs.skip_plugin_install != 'true'
      uses: actions/cache@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
      with:
        path: /tmp/gerrit-plugins
        key: gerrit-plugins-${{ inputs.plugin_version }}${{ inputs.cache_key_suffix }}
        restore-keys: |
          gerrit-plugins-${{ inputs.plugin_version }}
          gerrit-plugins-

    # Build custom Gerrit Docker image with uv and gerrit_to_platform
    - name: 'Build custom Gerrit image'
      if: inputs.enable_cache == 'true'
      shell: bash
      run: |
        # Build custom Gerrit image with uv and gerrit_to_platform
        GERRIT_VERSION="${{ inputs.gerrit_version }}"
        CUSTOM_IMAGE="gerrit-extended:${GERRIT_VERSION}"

        echo "Building custom Gerrit image..."
        echo "  Base: gerritcodereview/gerrit:${GERRIT_VERSION}"
        echo "  Target: ${CUSTOM_IMAGE}"

        if docker buildx build \
          --build-arg "GERRIT_VERSION=${GERRIT_VERSION}" \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --cache-to type=local,dest=/tmp/.buildx-cache,mode=max \
          -t "${CUSTOM_IMAGE}" \
          -f "${{ github.action_path }}/Dockerfile" \
          --load \
          "${{ github.action_path }}"; then
          echo "Custom image built successfully ‚úÖ"

          # Verify components (use --entrypoint="" to prevent Gerrit from starting)
          echo "Verifying custom image components..."
          if docker run --rm --entrypoint="" "${CUSTOM_IMAGE}" uv --version 2>/dev/null; then
            echo "  uv: ‚úÖ"
          else
            echo "  uv: ‚ö†Ô∏è not found"
          fi
          if docker run --rm --entrypoint="" "${CUSTOM_IMAGE}" which change-merged 2>/dev/null; then
            echo "  gerrit-to-platform: ‚úÖ"
          else
            echo "  gerrit-to-platform: ‚ö†Ô∏è not found"
          fi
        else
          echo "::warning::Failed to build custom image, will fall back to official image"
          docker pull "gerritcodereview/gerrit:${GERRIT_VERSION}" || {
            echo "Warning: Failed to pre-pull fallback image"
          }
        fi

    # Detect Gerrit API paths
    - name: 'Detect Gerrit API paths'
      id: detect-api-paths
      shell: bash
      env:
        GERRIT_SETUP: ${{ inputs.gerrit_setup }}
        DEBUG: ${{ inputs.debug }}
      run: |
        # Detect Gerrit API paths via redirect detection (Python)
        python3 "${{ github.action_path }}/scripts/detect-api-paths.py"

    # Start Gerrit instances
    - name: 'Start Gerrit instances'
      id: start-instances
      shell: bash
      env:
        GERRIT_SETUP: ${{ inputs.gerrit_setup }}
        SSH_PRIVATE_KEY: ${{ inputs.ssh_private_key }}
        SSH_KNOWN_HOSTS: ${{ inputs.ssh_known_hosts }}
        HTTP_USERNAME: ${{ inputs.http_username }}
        HTTP_PASSWORD: ${{ inputs.http_password }}
        BEARER_TOKEN: ${{ inputs.bearer_token }}
        AUTH_TYPE: ${{ inputs.auth_type }}
        REMOTE_SSH_USER: ${{ inputs.remote_ssh_user }}
        REMOTE_SSH_PORT: ${{ inputs.remote_ssh_port }}
        GERRIT_VERSION: ${{ inputs.gerrit_version }}
        PLUGIN_VERSION: ${{ inputs.plugin_version }}
        BASE_HTTP_PORT: ${{ inputs.base_http_port }}
        BASE_SSH_PORT: ${{ inputs.base_ssh_port }}
        SYNC_REFS: ${{ inputs.sync_refs }}
        REPLICATION_THREADS: ${{ inputs.replication_threads }}
        SYNC_ON_STARTUP: ${{ inputs.sync_on_startup }}
        FETCH_EVERY: ${{ inputs.fetch_every }}
        REPLICATION_TIMEOUT: ${{ inputs.replication_timeout }}
        SKIP_PLUGIN_INSTALL: ${{ inputs.skip_plugin_install }}
        ADDITIONAL_PLUGINS: ${{ inputs.additional_plugins }}
        GERRIT_INIT_ARGS: ${{ inputs.gerrit_init_args }}
        DEBUG: ${{ inputs.debug }}
        USE_API_PATH: ${{ inputs.use_api_path }}
        TUNNEL_HOST: ${{ inputs.tunnel_host }}
        TUNNEL_PORTS: ${{ inputs.tunnel_ports }}
        MAX_PROJECTS: ${{ inputs.max_projects }}
      run: |
        # Start Gerrit instances (Python)
        python3 "${{ github.action_path }}/scripts/start-instances.py"

    # Check service availability
    - name: "Check Gerrit service availability"
      if: inputs.check_service == 'true'
      shell: bash
      env:
        SKIP_PLUGIN_INSTALL: ${{ inputs.skip_plugin_install }}
        USE_API_PATH: ${{ inputs.use_api_path }}
        DEBUG: ${{ inputs.debug }}
      run: |
        # Check Gerrit service availability (Python)
        python3 "${{ github.action_path }}/scripts/check-services.py"

    # Add SSH authentication keys for user access
    - name: "Add SSH authentication keys"
      if: inputs.ssh_auth_keys != ''
      shell: bash
      env:
        SSH_AUTH_KEYS: ${{ inputs.ssh_auth_keys }}
        SSH_AUTH_USERNAME: ${{ inputs.ssh_auth_username }}
        USE_API_PATH: ${{ inputs.use_api_path }}
        DEBUG: ${{ inputs.debug }}
      run: |
        # Add SSH authentication keys for user access (Python)
        python3 "${{ github.action_path }}/scripts/setup-gerrit-user.py" \
          --instances-file "$WORK_DIR/instances.json" \
          --loop-instances

    # Trigger initial replication
    - name: "Trigger initial replication"
      if: inputs.sync_on_startup == 'true'
      shell: bash
      env:
        SKIP_PLUGIN_INSTALL: ${{ inputs.skip_plugin_install }}
        AUTH_TYPE: ${{ inputs.auth_type }}
        SYNC_ON_STARTUP: ${{ inputs.sync_on_startup }}
        REQUIRE_REPLICATION_SUCCESS: ${{ inputs.require_replication_success }}
        REPLICATION_WAIT_TIMEOUT: ${{ inputs.replication_wait_timeout }}
        FETCH_EVERY: ${{ inputs.fetch_every }}
        DEBUG: ${{ inputs.debug }}
      run: |
        # Trigger initial replication (Python)
        python3 "${{ github.action_path }}/scripts/trigger-replication.py"

    # Verify replication success
    - name: "Verify replication success"
      if: inputs.sync_on_startup == 'true' && inputs.require_replication_success == 'true'
      shell: bash
      env:
        REPLICATION_WAIT_TIMEOUT: ${{ inputs.replication_wait_timeout }}
        FETCH_EVERY: ${{ inputs.fetch_every }}
        DEBUG: ${{ inputs.debug }}
      run: |
        # Verify replication success (Python)
        python3 "${{ github.action_path }}/scripts/verify-replication.py"

    # Collect outputs
    - name: "Collect outputs"
      id: collect-outputs
      shell: bash
      env:
        DEBUG: ${{ inputs.debug }}
      run: |
        # Collect outputs (Python)
        python3 "${{ github.action_path }}/scripts/collect-outputs.py"

    # Terminate containers when finished
    - name: "Terminate containers when finished"
      if: inputs.exit == 'true'
      shell: bash
      env:
        ENABLE_CACHE: ${{ inputs.enable_cache }}
        DEBUG: ${{ inputs.debug }}
      run: |
        # Terminate containers when finished (Python)
        python3 "${{ github.action_path }}/scripts/cleanup.py"

    # Container persistence message
    - name: "Containers will continue/persist"
      if: inputs.exit != 'true'
      shell: bash
      run: |
        # Containers will continue/persist (Python)
        python3 -c "
        import json, os, pathlib
        summary = os.environ.get('GITHUB_STEP_SUMMARY', '')
        if not summary:
            exit(0)
        lines = ['**Containers Status** üê≥', '',
                 'Containers have detached and will continue/persist', '',
                 'To manually cleanup later, run:', '\`\`\`bash']
        instances_path = pathlib.Path(os.environ.get('WORK_DIR', '')) / 'instances.json'
        if instances_path.is_file():
            data = json.loads(instances_path.read_text())
            for slug in sorted(data):
                cid = data[slug].get('cid', '')
                if cid:
                    lines.append(f'docker kill {cid}')
        lines.extend(['\`\`\`', ''])
        with open(summary, 'a') as fh:
            fh.write('\n'.join(lines) + '\n')
        "
